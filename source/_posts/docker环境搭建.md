---
title: docker环境搭建
date: 2020-01-08 17:47:18
tags: 
  - Java
  - docker
description: 
cover: http://120.27.226.80:8088/images/1578477001703.jpg
top_img: http://120.27.226.80:8088/images/1578477001703.jpg
categories: 运维
---

**理解Docker容器**

Docker容器将一块应用打包到一个完整的文件系统中，在该文件系统中包含了该应用要运行的所有要求：代码，运行时，系统工具，系统库 - 任何你安装在服务器上的东西。这就能保证他将会以同样的方式运行，无论它运行在什么样的环境中。

网上找的例子，感觉很形象，Docker的思想来自于集装箱，在一艘大船上，可以把货物规整的摆放起来。并且各种各样的货物被集装箱标准化了，集装箱和集装箱之间不会互相影响。那么我就不需要专门运送水果的船和专门运送化学品的船了。只要这些货物在集装箱里封装的好好的，那我就可以用一艘大船把他们都运走。

简单来讲一句话，docker允许我们连环境待应用统一打包用于开发。

**Docker的作用**

正常情况下，不同的应用程序可能会有不同的应用环境，比如java,php等开发所需要的开发环境就很不一样，若是都部署在一台服务器上，会比较麻烦，而且还有端口冲突等问题。若是不是在多台服务器上，成本就会上升。

常规来讲，这个问题我们可以在同一台服务器上配置多个虚拟机来解决。从某种意义上说，docker可以当成虚拟机来用，单具有以下优势：

- 更高效的利用系统资源：由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。
- 更快速的启动时间：传统的虚拟机技术启动应用服务往往需要数分钟，而Docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。
- 一致的运行环境，方便迁移：开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一 致，导致有些bug 并未在开发过程中被发现。而Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现「这段代码在我机器上没问题啊」这类问题。

**环境搭建**

可以使用官方提供的脚本来安装docker

```shell
curl -sSl https://get.docker.com/ | sh
```

![](http://120.27.226.80:8088/images/1578477066798.png)

安装成功后启动docker服务：

```shell
 service docker start
```

docker 客户端非常简单 ,我们可以直接输入 docker 命令来查看到 Docker 客户端的所有命令选项。

![](http://120.27.226.80:8088/images/1578477137476.png)

**Docker 镜像使用**

当运行容器时，使用的镜像如果在本地中不存在，docker 就会自动从 docker 镜像仓库中下载，默认是从 Docker Hub 公共镜像源下载。

可以输入docker images命令查看本机镜像

![](http://120.27.226.80:8088/images/1578477518575.png)

当我们在本地主机上使用一个不存在的镜像时 Docker 就会自动下载这个镜像。如果我们想预先下载这个镜像，我们可以使用 docker pull 命令来下载它。

**Docker Hello World**

Docker 允许你在容器内运行应用程序， 使用 docker run 命令来在容器内运行一个应用程序。

Aocker安装完毕之后，我们可以尝试运行一下让docker 输入HelloWorld

![](http://120.27.226.80:8088/images/1578477548689.png)

输入docker images 命令可以查看当前系统下的镜像：

![](http://120.27.226.80:8088/images/1578548644383.png)

以上命令完整的意思可以解释为：Docker 以 ubuntu15.10 镜像创建一个新容器，然后在容器里执行 bin/echo "Hello world"，然后输出结果。

**运行交互式的容器**

运行命令

```shell
docker run -i -t ubuntu:15.10 /bin/bash
```

![](http://120.27.226.80:8088/images/1578548709772.png)

此时我们已进入一个 ubuntu15.10系统的容器

-t:在新容器内指定一个伪终端或终端。

-i:允许你对容器内的标准输入 (STDIN) 进行交互。

可以使用exit命令退出

**启动容器（后台模式）**

执行命令 

```shell
docker run -d ubuntu:15.10 /bin/sh -c "while true; do echo hello world; sleep 1; done"
```

![](http://120.27.226.80:8088/images/1578548763943.png)

在输出中，我们没有看到期望的"hello world"，而是一串长字符

3fa0f87bb8a3bedceff4e539776d6d6ba6842406f45274d2d79233be4433acaa

这个长字符串叫做容器ID，对每个容器来说都是唯一的，我们可以通过容器ID来查看对应的容器发生了什么。

使用docker ps命令可以查看正在运行的容器

![](http://120.27.226.80:8088/images/1578548797207.png)

CONTAINER ID:容器ID

NAMES:自动分配的容器名称