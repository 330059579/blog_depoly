---
title: TCP协议三次握手抓包分析
date: 2020-01-08 17:02:49
tags: 
  - 网络通信
  - TCP
description: 
cover: http://120.27.226.80:8088/images/1578474419993.jpg
top_img: http://120.27.226.80:8088/images/1578474419993.jpg
categories: 网络通信
---

**1.OSI七层模型**

![](http://120.27.226.80:8088/images/1578474464436.png)

- 物理层 ：主要定义了物理设备的标准，传输比特流

- 数据链路层：定义了如何格式化数据，交换机工作在此层

- 网络层：将网络地址转换为对应的物理地址，并根据网络拥塞，路由花费等决定访问路由，路由器在此工作，主要关注ip协议

- 传输层：通信过程中需要发送大量数据，而网络又可能会断连，为了保证数据不丢失，需要将数据转化为多个数据包，并确定了这些数据包丢失重新传送，以及传送后按正确顺序重组，传输层解决了数据传输和传输质量问题，是osi模型中对重要的一层。著名的TCP， UDP工作在此层。

  ![](http://120.27.226.80:8088/images/1578474509230.png)
  
-  会话层：直接使用TCP和UDP很不方便，需要使用会话层管理会话

- 表示层：解决不同以同语法不一致问题。

  ![](http://120.27.226.80:8088/images/1578474617361.png)

- 应用层：我们在发送请求时，必须按照一定的格式封装出消息头，并且提供消息体中数据的长度，以便接收方按此解析。没有这一层，数据也可以传递，单无法被接受方解析，这层的协议就是常用的http协议

**2.TCP/IP 四层架构**

TCP/IP 四层架构不止是指tcp 和ip 协议，而是用来进行通信时，协议群的统称

![](http://120.27.226.80:8088/images/1578474656064.png)

**1.TCP三次握手：**

ip协议时无连接协议，不会占用两台计算机之间的通信线路，ip降低了对网络线路的需求，ip协议将数据包路由到目的地，但ip协议没有做任何事情来保证包的顺序或者是否丢失，所以ip协议是不可靠的，这是就需要他的上级协议TCP协议来进行控制

tcp将应用层的数据流分割成报文段，并发送给目标节点的TCP层

每个数据包都有序号 即seq 对方收到后发送ack确认，未收到则重传。

三次握手流程如下：

![](http://120.27.226.80:8088/images/1578474695457.png)

SYN为1表示请求建立连接

ack为确认字段 为seq+1

**通过抓包来更深一步的了解三次握手**

使用的抓包软件为wireshark

![](http://120.27.226.80:8088/images/1578474743603.png)

设置捕获过滤器：

捕获---选项：

![](http://120.27.226.80:8088/images/1578474797713.png)

![](http://120.27.226.80:8088/images/1578474814991.png)

浏览器中访问地址http://myo2o.yitiaojieinfo.com/myo2o/frontend/index

抓到数据如下：

由于抓到的数据太多，需要进行过滤：

先找出http协议，路径为[/myo2o/frontend/index](http://myo2o.yitiaojieinfo.com/myo2o/frontend/index)

![](http://120.27.226.80:8088/images/1578474874981.png)

tcp的握手就会出现在附近

从上图的ip可以看出，我们本地的ip是192.168.199.105， 而远程服务器的ip是115.25.159.6

用正则表达式进行筛选

![](http://120.27.226.80:8088/images/1578474915355.png)

因为三次握手时对方服务器优势作为源主机，有时作为目标主机，所以我们都需要过滤出来

结果：

由于有多个异步请求，所以我们只关注其中一个三次握手

![](http://120.27.226.80:8088/images/1578474952485.png)

三次握手完成，可以进行相互通信

![](http://120.27.226.80:8088/images/1578474980766.png)

**2.TCP 的四次挥手**

四次挥手是指服务器和客户端在断开连接时，总共需要发送四个包来确认断开

服务端或客户端任意方执行close来触发

假设客户端主动断开连接

![](http://120.27.226.80:8088/images/1578475013209.png)

1.当服务器收到FIN=1的关闭请求后，会发送一个确认报文，又因为此时服务端的数据有可能并未接收完成，所以不会马上断开连接， 而是进入CLOSE-WAIT等待状态，此时客户端已经不再发送数据，但是服务端发送数据，客户端仍然能够收到

2.当客户端收到服务器发送的确认报文后，会进入FIN-WAIT2状态，等待服务器断开连接

3.服务器确认可以断开连接后，服务器发送连接断开报文

4.客户端发出确认报文，进入TIME-WAIT状态，等待 2 * MSL 的时间后才真正断开连接

MSL 最长报文段寿命，linux下一般为30s

![](http://120.27.226.80:8088/images/1578475052288.png)

为什么有TIME-WAIT状态

1.确保有足够时间让对端收到ACK包

2.有足够时间让这个连接不会因为路由器缓存和后面的连接混到一起

为什么需要四次挥手

没有YY的那么复杂

因为TCP连接是一个全双工的连接

即再同意时间允许服务器向客户端传送，也允许客户端向服务器传送数据

所以发送方和接收方都需要FIN和FIN报文才能断开连接，所以产生了四次

代码中如果某些连接没有及时释放，会导致客户端虽然发送了断开连接请求，单服务端代码并没有释放连接，从而出现了大量CLOSE-WAIT的连接

netstat -n | awk '/^tcp/{++S[$NF]}END{for(a in S) print a,S[a]}'

linux服务器输入此命令，可以看到有多少连接处于等待断开的状态

![](http://120.27.226.80:8088/images/1578475155896.png)

这里只有一个如果有几千个连接处于CLOSE-WAIT，就需要注意

因为linux服务器会为每个用户分配有限的文件句柄数，而连接数又是个文件句柄数一一对应的，所以到达上限之后，会出现大量 too many open files 异常，以及软件服务器的崩溃